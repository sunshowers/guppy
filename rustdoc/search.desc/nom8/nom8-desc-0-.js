searchState.loadedDescShard("nom8", 0, "nom, eating data byte by byte\nThe <code>Err</code> enum indicates the parser was not successful\nContains the error value\nThe parser had an error (recoverable)\nThe parser had an unrecoverable error: we got to the right …\nExtension trait to convert a parser’s <code>IResult</code> to a more …\nHolds the result of parsing functions\nThere was not enough data\nConvert an <code>Input</code> into an appropriate <code>Output</code> type\nContains information on needed data if a parser returned …\nContains the success value\nAll nom parsers implement this trait\nContains the required data size in bytes\nNeeds more data, but we do not know how much\nApplies a second parser after the first one, return their …\nApplies a second parser after the first one, return their …\nApplies a second parser over the output of the first one\nApplies a second parser over the output of the first one\nBit level parsers\nChoice combinators\nTreat <code>&amp;mut Self</code> as a parser\nTreat <code>&amp;mut Self</code> as a parser\nParsers recognizing bytes streams\nCharacter specific parsers and combinators\nList of parsers and combinators\nTransforms <code>Incomplete</code> into <code>Error</code>\nTransforms <code>Incomplete</code> into <code>Error</code>\nIf parsing fails, add context to the error\nIf parsing fails, add context to the error\nAutomatically converts between errors if the underlying …\nPrints a message and the input if the parser fails.\nPrints a message and the input if the parser fails.\nConvert the parser’s error to another type using …\nConvert the parser’s error to another type using …\nError management\nCreates a parse error from a <code>ErrorKind</code>, the position in …\nCreates a parse error from a <code>ErrorKind</code> and the position in …\nConverts the parser’s <code>IResult</code> to a type that is more …\nConverts the parser’s <code>IResult</code> to a type that is more …\nCreates a second parser from the output of the first one, …\nCreates a second parser from the output of the first one, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nInput capability for nom combinators to parse\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an <code>Input</code> into an appropriate <code>Output</code> type\nTests if the result is Incomplete\nIndicates if we know how many bytes we need\nLib module to re-export everything needed from <code>std</code> or <code>core</code>/…\nMaps a function over the result of a parser\nMaps a function over the result of a parser\nMaps a <code>Needed</code> to <code>Needed</code> by applying a function to a …\nApplies the given function to the inner error\nMaps <code>Err&lt;error::Error&lt;T&gt;&gt;</code> to <code>Err&lt;error::Error&lt;U&gt;&gt;</code> with the …\nMaps <code>Err&lt;(T, ErrorKind)&gt;</code> to <code>Err&lt;(U, ErrorKind)&gt;</code> with the …\nApplies a function returning an <code>Option</code> over the result of …\nApplies a function returning an <code>Option</code> over the result of …\nApplies a function returning a <code>Result</code> over the result of a …\nApplies a function returning a <code>Result</code> over the result of a …\nCombinators applying their child parser multiple times\nCreates <code>Needed</code> instance, returns <code>Needed::Unknown</code> if the …\nParsers recognizing numbers\nApplies a second parser over the input if the first one …\nApplies a second parser over the input if the first one …\nConvert the parser’s output to another type using …\nConvert the parser’s output to another type using …\nA parser takes in input type, and returns a <code>Result</code> …\nCore concepts available for glob import\nIf the child parser was successful, return the consumed …\nIf the child parser was successful, return the consumed …\nCombinators applying parsers in sequence\nIf the child parser was successful, return the location of …\nIf the child parser was successful, return the location of …\nObtaining ownership\nObtaining ownership\nObtaining ownership\nObtaining ownership\nReturns the provided value if the child parser succeeds.\nReturns the provided value if the child parser succeeds.\nReturns the result of the child parser if it satisfies a …\nReturns the result of the child parser if it satisfies a …\nif the child parser was successful, return the consumed …\nif the child parser was successful, return the consumed …\nif the child parser was successful, return the location of …\nif the child parser was successful, return the location of …\nConverts a byte-level input to a bit-level input, for …\nCounterpart to <code>bits</code>, <code>bytes</code> transforms its bit stream input …\nBit level parsers\nBit level parsers\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nHelper trait for the alt() combinator.\nHelper trait for the permutation() combinator.\nTests a list of parsers one by one until one succeeds.\nTests each parser in the tuple and returns the result of …\nApplies a list of parsers in any order.\nTries to apply all parsers in the tuple in various orders …\nMatches one token\nParsers recognizing bytes streams, complete input version\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns a token that does not match the pattern\nReturns a token that matches the pattern\nParsers recognizing bytes streams, streaming version\nRecognizes a pattern\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a pattern is …\nReturns the longest (at least 1) input slice till a pattern…\nReturns the input slice up to the first occurrence of the …\nReturns the non empty input slice up to the first …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice that …\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nRecognizes a pattern\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the non empty input slice up to the first …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice  that …\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nRecognizes a pattern.\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the non empty input slice up to the first …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice  that …\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nCharacter specific parsers and combinators, complete input …\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes floating point number in text format and …\nRecognizes floating point number in text format and …\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes floating point number in a byte string and …\nRecognizes a floating point number in text format\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nCharacter specific parsers and combinators, streaming …\nMatches a tab character ‘\\t’.\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nMatches one byte as a character. Note that the input type …\nRecognizes one character.\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a character that is not in the provided …\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nMatches a tab character ‘\\t’.\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nMatches one byte as a character. Note that the input type …\nRecognizes one character.\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a character that is not in the provided …\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nMatches a tab character ‘\\t’.\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nImplementation of <code>Parser::and</code>\nImplementation of <code>Parser::and_then</code>\nImplementation of <code>Parser::by_ref</code>\nImplementation of <code>Parser::complete</code>\nImplementation of <code>Parser::err_into</code>\nImplementation of <code>Parser::flat_map</code>\nImplementation of <code>Parser::map</code>\nImplementation of <code>Parser::map_opt</code>\nImplementation of <code>Parser::map_res</code>\nImplementation of <code>Parser::or</code>\nImplementation of <code>Parser::output_into</code>\nMain structure associated to the iterator function.\nImplementation of <code>Parser::recognize</code>\nImplementation of <code>Parser::span</code>\nImplementation of <code>Parser::value</code>\nImplementation of <code>Parser::verify</code>\nImplementation of <code>Parser::with_recognized</code>\nImplementation of <code>Parser::with_span</code>\nSucceeds if all the input has been consumed by its child …\nTransforms Incomplete into <code>Error</code>.\nCalls the parser if the condition is met.\nif the child parser was successful, return the consumed …\nTransforms an <code>Err::Error</code> (recoverable) to <code>Err::Failure</code> …\nreturns its input if it is at the end of input data\nA parser which always fails.\nReturns the remaining input if parsing was successful, or …\nCreates a new parser from the output of the first parser, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nautomatically converts the child parser’s result to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an iterator from input data and a parser.\nMaps a function on the result of a parser.\nApplies a function returning an <code>Option</code> over the result of …\nApplies a parser over the result of another one.\nApplies a function returning a <code>Result</code> over the result of a …\nSucceeds if the child parser returns an error.\nOptional parser, will return <code>None</code> on <code>Err::Error</code>.\nTries to apply its parser without consuming the input.\nIf the child parser was successful, return the consumed …\nReturn the remaining input.\nReturn the length of the remaining input.\na parser which always succeeds with given value without …\nReturns the provided value if the child parser succeeds.\nReturns the result of the child parser if it satisfies a …\nImplementation of <code>Parser::context</code>\nStatic string added by the <code>context</code> function\nThis trait is required by the <code>context</code> combinator to add a …\nImplementation of <code>Parser::dbg_err</code>\ndefault error type, only contains the error’ location …\nIndicates which parser returned an error\nThis trait is required by the <code>map_res</code> combinator to …\nError kind given by various nom parsers\nThis trait must be implemented by the error type of a nom …\nThis error type accumulates errors and their position when …\nError context for <code>VerboseError</code>\nCreates a new error from an input position, a static …\nCombines an existing error with a new one created from the …\nCombines an existing error with a new one created from the …\nnom error code\nCreate a new error from an input position, a static string …\nTransforms a <code>VerboseError</code> into a trace with input position …\nPrints a message and the input if the parser fails.\nConverts an ErrorKind to a text description\nList of errors accumulated by <code>VerboseError</code>, containing the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an error from an input position and an expected …\nCreates an error from the input position and an ErrorKind\nCreates a new error from an input position, an ErrorKind …\nCreate a new error from an input position and an external …\nCreate a new error from an input position and an external …\nposition of the error in the input data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an error from the input position and an ErrorKind\ncreates a new basic error\nCombines two existing errors. This function is used to …\nHelper trait for types that can be viewed as a byte slice\nTransforms common types to a char for basic token parsing\nAbstracts comparison operations\nIndicates whether a comparison was successful, an error, or\nComplete counterpart\nComparison failed\nEquivalent From implementation to avoid orphan rules in …\nAbstracts something which can extend an <code>Extend</code>. Used to …\nThe type that will be produced\nLook for a substring in self\nCheck if a token in in a set of possible tokens\nHelper trait to show a byte slice as a hex dump\nWe need more data to be sure\nMarks the input as being the complete buffer or a partial …\nAbstracts common iteration operations on the input type\nAbstract method to calculate the input length\nAbstracts slicing operations\nMethods to take as much input as possible until the …\nConvert an <code>Input</code> into an appropriate <code>Output</code> type\nThe current input type is a sequence of that <code>Item</code> type.\nThe current input type is a sequence of that <code>Item</code> type.\nThe current input type is a sequence of that <code>Item</code> type.\nAn iterator over the input type, producing the item and …\nAn iterator over the input type, producing the item\nAllow collecting the span of a parsed token\nNumber of indices input has advanced since start of parsing\nUseful functions to calculate the offset between slices …\nComparison was successful\nOutput type\nUsed to integrate <code>str</code>’s <code>parse()</code> method\nSlicing operations using ranges.\nThread global state through your parsers\nMark the input as a partial buffer for streaming input.\nStreaming counterpart\nHelper trait to convert numbers to usize.\nDummy trait used for default implementations (currently …\nCasts the input type to a byte slice\nMakes a char from self\nCompares self to another value for equality\nCompares self to another value for equality independently …\nTransform to another error type\nAccumulate the input into an accumulator\nReturns the byte position of the substring if it is found\nReturns true if self contains the token\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInner input being wrapped in state\nCalculates the input length, as indicated by its name, and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to complete counterpart\nConvert to complete counterpart\nConvert an <code>Input</code> into an appropriate <code>Output</code> type\nConvert to streaming counterpart\nTests that self is an alphabetic character\nTests that self is an alphabetic character or a decimal …\nTests that self is a decimal digit\nTests that self is an hex digit\nTests if byte is ASCII newline: \\n\nTests that self is an octal digit\nTests that self is ASCII space or tab\nReturns an iterator over the elements\nReturns an iterator over the elements and their byte …\nGets the len in bytes for self\nNumber of indices input has advanced since start of parsing\nConvert an <code>Output</code> type to be used as <code>Input</code>\nWrap another Input with span tracking\nCreate a new <code>Extend</code> of the correct type\nOffset between the first byte of self and the first byte …\nSucceeds if <code>parse()</code> succeeded. The byte slice …\nFinds the byte position of the element\nSlices self according to the range argument\nGet the byte offset from the element’s position in the …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nUser-provided state\nReturns a slice of <code>count</code> bytes. panics if count &gt; length\nSplit the stream at the <code>count</code> byte offset. panics if count …\nConverts the value of <code>self</code> to a hex dump, returning the …\nConverts the value of <code>self</code> to a hex dump beginning at <code>from</code> …\nconverts self to usize\ninternal std exports for no_std compatibility\nRuns the embedded parser <code>count</code> times, gathering the …\nRuns the embedded parser repeatedly, filling the given …\nRepeats the embedded parser, calling <code>g</code> to gather the …\nRepeats the embedded parser, calling <code>g</code> to gather the …\nRepeats the embedded parser <code>m..=n</code> times, calling <code>g</code> to …\nGets a number from the first parser, then applies the …\nGets a number from the parser and returns a subslice of …\nGets a number from the first parser, takes a subslice of …\nRepeats the embedded parser, gathering the results in a <code>Vec</code>…\nRepeats the embedded parser, counting the results\nRuns the embedded parser, gathering the results in a <code>Vec</code>.\nRuns the embedded parser, counting the results.\nRepeats the embedded parser <code>m..=n</code> times\nApplies the parser <code>f</code> until the parser <code>g</code> produces a result.\nAlternates between two parsers to produce a list of …\nAlternates between two parsers to produce a list of …\nBig endian\nConfigurable endianness\nLittle endian\nWill match the host’s endianness\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nParsers recognizing numbers, complete input version\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nReturns the argument unchanged.\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nCalls <code>U::from(self)</code>.\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 byte integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nParsers recognizing numbers, streaming version\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in text format and …\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nRecognizes floating point number in text format and …\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 byte integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in a byte string and …\nRecognizes a floating point number in text format\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in text format and …\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nRecognizes floating point number in text format and …\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 bytes integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes a floating point number in text format and …\nRecognizes a floating point number in text format\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nHelper trait for the tuple combinator.\nMatches an object from the first parser and discards it, …\nGets an object from the first parser, then gets another …\nParses the input and returns a tuple of results of each …\nMatches an object from the first parser and discards it, …\nGets an object from the first parser, then matches an …\nGets an object from the first parser, then matches an …\nApplies a tuple of parsers one by one and returns their …")